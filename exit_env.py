# -*- coding: utf-8 -*-
"""Untitled31.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eDQJfcn67pLYjStx1u_1bMsFj-uW2AFa
"""

from gym import spaces
import numpy as np
import pandas as pd
import gym


class ExitEnv(gym.Env):
    def __init__(self, trade_df, df_prices, feature_columns, max_exit_delay=20):
        super(ExitEnv, self).__init__()
        self.trade_df = trade_df.reset_index(drop=True)
        if df_prices.index.name != "Date":
            if "Date" in df_prices.columns:
                df_prices = df_prices.set_index("Date")
            else:
                raise ValueError("❌ ERRORE: 'Date' non è né colonna né indice.")
        self.df_prices = df_prices
        self.feature_columns = feature_columns
        self.max_exit_delay = max_exit_delay
        self.action_space = spaces.Discrete(2)
        self.observation_space = spaces.Box(
            low=-np.inf, high=np.inf,
            shape=(len(feature_columns) + 5,), dtype=np.float32
        )
        self.maintenance_margin_rate = 0.25

    def reset(self):
        self.current_trade = np.random.randint(0, len(self.trade_df))
        self.exit_step = 1
        self.done = False
        self.trade = self.trade_df.iloc[self.current_trade].copy()
        self.entry_date = pd.to_datetime(self.trade['entry_date'])
        self.exit_date = self.df_prices.index[-1]
        self.entry_price = self.trade['entry_price']
        self.position = self.trade['position']
        self.trade['leverage'] = self.trade.get('leverage', 1)
        valid_dates = self.df_prices.index
        pos = valid_dates.get_indexer([self.entry_date], method='bfill')[0]
        if pos + 1 < len(valid_dates):
            self.date = valid_dates[pos + 1]
        else:
            self.date = valid_dates[pos]
        self.max_return = 0
        self.prev_return = 0
        return self._get_observation()

    def _get_observation(self):
        if self.date not in self.df_prices.index:
            return np.zeros(self.observation_space.shape)
        feat = self.df_prices.loc[self.date, self.feature_columns].values.astype(np.float32)
        current_price = self.df_prices.loc[self.date, 'Close']
        current_return = (current_price / self.entry_price - 1) * self.position
        self.max_return = max(self.max_return, current_return)
        drawdown = (current_return - self.max_return)
        obs = np.append(feat, [self.exit_step, current_return, self.max_return, drawdown, self.position])
        return obs

    def step(self, action):
        reward = 0
        done = False
        info = {}

        if self.date not in self.df_prices.index:
            return self._get_observation(), -1.0, True, {}

        current_price = self.df_prices.loc[self.date, 'Close']
        current_return = (current_price / self.entry_price - 1) * self.position
        self.max_return = max(self.max_return, current_return)
        drawdown = current_return - self.max_return

        current_value = 1 + current_return
        if current_value < self.maintenance_margin_rate:
            # Calcolo perdita realistica in base alla leva utilizzata
            capital_loss = 1 - current_value  # perdita in percentuale sul capitale iniziale
            leveraged_return = -capital_loss * self.trade.get('leverage', 1)  # leva moltiplica la perdita
            leveraged_return = max(leveraged_return, -1.0)  # limita al -100%

            reward += leveraged_return  # penalità proporzionale alla leva
            done = True
            info = {
                'exit_date': self.date,
                'exit_price': current_price,
                'return': leveraged_return,
                'return_max': self.max_return,
                'drawdown': drawdown,
                'duration': self.exit_step,
                'margin_call': True
            }
            return self._get_observation(), reward, done, info

        decay_weight = self.trade['decay_weight'] if 'decay_weight' in self.trade else 1.0
        reward = (current_return - self.prev_return - 0.0007 * self.exit_step) * decay_weight
        self.prev_return = current_return

        if action == 1 or self.exit_step >= self.max_exit_delay or self.date >= self.exit_date:
            if current_return > 0.01:
                reward += 0.005
            elif current_return < -0.005:
                reward -= 0.01
            done = True
            info = {
                'exit_date': self.date,
                'exit_price': current_price,
                'return': current_return,
                'return_max': self.max_return,
                'drawdown': drawdown,
                'duration': self.exit_step
            }
        else:
            self.exit_step += 1
            self.date += pd.Timedelta(days=1)
            forward_step = 0
            while self.date not in self.df_prices.index and self.date <= self.exit_date:
                self.date += pd.Timedelta(days=1)
                forward_step += 1
                if forward_step > 10:
                    return self._get_observation(), -1.0, True, {'exit_date': self.date, 'exit_price': np.nan, 'return': 0.0, 'duration': self.exit_step}

        return self._get_observation(), reward, done, info